use crate::regex::RE;
use crate::parser::replacer;
use regex::{Captures, Regex};

type ListItem<'a> = (usize, usize, &'a str, String);

fn parse_list_items((index, raw): (usize, &str)) -> ListItem {
  // Convert the line into a String
  let mut text: String = raw.to_string();

  // Capture the indent of the line
  let re_start_whitespace: Regex = Regex::new(r"^[\s]+").unwrap();
  let indent: usize = match re_start_whitespace.captures(raw) {
    Some(captures) => captures[0].len(),
    None => 0
  };

  // 1. Remove whitespace from start and end of line
  // 2. Remove numeric identifiers from ordered lists (autogenerated by browser engine)
  let re_numeric_identifier: Regex = Regex::new(r"^([0-9]+)[\s]{0,}\.[\s]{0,}").unwrap();
  text = re_numeric_identifier.replace(text.trim(), ". ").to_string();

  // Get the list item format (ol | ul)
  let format: &str = if text.starts_with("*") || text.starts_with("-") { "ul" } else { "ol" };
  let re_identifier: Regex = Regex::new(r"^(\.|\*|\-)[\s]{0,}").unwrap();
  text = re_identifier.replace(text.trim(), "").trim().to_string();

  // Convert checkboxes to HTML
  let re_empty_checkbox: Regex = Regex::new(r"[\s]{0,}\[[\s]{0,}\][\s]{0,}").unwrap();
  text = re_empty_checkbox.replace(text.trim(), "<input type=\"checkbox\" /> ").to_string();
  let re_checked_checkbox: Regex = Regex::new(r"[\s]{0,}\[[\s]{0,}[xX]{1}[\s]{0,}\][\s]{0,}").unwrap();
  text = re_checked_checkbox.replace(text.trim(), "<input type=\"checkbox\" checked=\"checked\" /> ").to_string();
  // return the indent and text
  (index, indent, format, format!("<li>{text}</li>"))
}

pub fn default(html: &mut String) {
  replacer(html, RE::LIST_ITEM, | capture: Captures | {
    // Ignore empty lists
    let re_empty_list: Regex = Regex::new(r"([0-9]|\*|\-|\.)+").unwrap();
    if re_empty_list.replace_all(&capture[0], "").trim().len() < 1 {
      return capture[0].to_string();
    }

    // Get the list data
    let list: Vec<ListItem> = capture[0].trim().lines().enumerate().map(parse_list_items).collect::<Vec<ListItem>>();

    // Store the previous indent, the result string and formats for open lists
    let mut prev_indent: usize = 0;
    let mut result: String = format!("{}{}<{}>\n", &capture[1], if capture[1].len() < 1 { "" } else { "\n" }, list[0].2);
    let mut open_lists: Vec<(String, &str)> = vec![];

    // Iterate the list items
    for (index, indent, format, list_item) in &list {
      // Whitespace for HTML
      let whitespace: String = " ".repeat(*indent);
      let whitespace_more: String = " ".repeat(*indent + 2);

      // If the current list item's indent is equal to the next list item's indent
      if *indent == prev_indent {
        // Add the current list item to the list
        result.push_str(&format!("{whitespace_more}{list_item}\n"));
      }
      // If the current list item's indent is greater than the next list item's indent
      else if *indent > prev_indent {
        // Start a new child list and add the current list item to it
        result.push_str(&format!("{whitespace}<{format}>\n{whitespace_more}{list_item}\n"));
        // Update the open lists vector
        open_lists.push((whitespace, format));
      }
      // If the current list item's indent is less than the next list item's indent
      else if *indent < prev_indent {
        // Close the previous list
        let (_, prev_indent, prev_format, _): ListItem = list[index - 1];
        result.push_str(&format!("{}</{}>\n", " ".repeat(prev_indent), prev_format));
        open_lists.pop();
        // Continue with the previous list's parent list
        result.push_str(&format!("{whitespace_more}{list_item}\n"));
      }

      // Update the previous indent
      prev_indent = *indent;
    }

    // Close all unclosed open list using whitespace and format indicators from the `open_lists` vector
    while open_lists.len() > 0 {
      let (whitespace, format): (String, &str) = open_lists.pop().unwrap();
      result.push_str(&format!("{whitespace}</{format}>\n"));
    }

    // Close the parent list
    result.push_str(&format!("</{}>\n", list[0].2));

    // Return the result
    result
  });
}
