use crate::core::re;
use regex::{Captures, Regex};

// List item type shorthand
type ListItem<'a> = (usize, usize, &'a str, String);

// Store pre defined regular expressions (to prevent duplicates inside loops)
struct Expressions {
  pub empty_list: Regex,
  pub start_whitespace: Regex,
  pub numeric_identifier: Regex,
  pub identifier: Regex,
  pub empty_checkbox: Regex,
  pub checked_checkbox: Regex
}

// Extract and remove MD syntax from list items
fn parse_list_items<'a>(index: usize, raw: &'a str, regex: &'a Expressions) -> ListItem<'a> {
  // Convert the line into a String
  let mut text: String = raw.to_string();

  // Capture the indent of the line
  let indent: usize = match regex.start_whitespace.captures(raw) {
    Some(captures) => captures[0].len(),
    None => 0
  };

  // 1. Remove whitespace from start and end of line
  // 2. Remove numeric identifiers from ordered lists (autogenerated by browser engine)
  text = regex.numeric_identifier.replace(text.trim(), ". ").to_string();

  // Get the list item format (ol | ul)
  let format: &str = if text.starts_with("*") || text.starts_with("-") { "ul" } else { "ol" };
  text = regex.identifier.replace(text.trim(), "").trim().to_string();

  // Convert checkboxes to HTML
  text = regex.empty_checkbox.replace(text.trim(), "<input type=\"checkbox\" /> ").to_string();
  text = regex.checked_checkbox.replace(text.trim(), "<input type=\"checkbox\" checked=\"checked\" /> ").to_string();
  // return the indent and text
  (index, indent, format, format!("<li>{text}</li>"))
}

// Parse: Lists and task lists
pub fn default(html: &mut String) {
  // Predefine regular expressions
  let regex: Expressions = Expressions {
    empty_list: re::from(r"([0-9]|\*|\-|\.)+"),
    start_whitespace: re::from(r"^[\s]+"),
    numeric_identifier: re::from(r"^([0-9]+)[\s]{0,}\.[\s]{0,}"),
    identifier: re::from(r"^(\.|\*|\-)[\s]{0,}"),
    empty_checkbox: re::from(r"[\s]{0,}\[[\s]{0,}\][\s]{0,}"),
    checked_checkbox: re::from(r"[\s]{0,}\[[\s]{0,}[xX]{1}[\s]{0,}\][\s]{0,}"),
  };

  re::parse(html, re::from(re::LIST_ITEM), | capture: Captures | {
    // Ignore empty lists
    if regex.empty_list.replace_all(&capture[0], "").trim().is_empty() {
      return capture[0].to_string();
    }

    // Get the list data
    let list: Vec<ListItem> = capture[0].trim().lines().enumerate()
      .map(| (index, raw): (usize, &str) | parse_list_items(index, raw, &regex))
      .collect::<Vec<ListItem>>();

    // Store the previous indent, the result string and formats for open lists
    let mut prev_indent: usize = 0;
    let mut result: String = format!("{}{}<{}>\n", &capture[1], if capture[1].len() < 1 { "" } else { "\n" }, list[0].2);
    let mut open_lists: Vec<(String, &str)> = vec![];

    // Iterate the list items
    for (index, indent, format, list_item) in &list {
      // Whitespace for HTML
      let whitespace: String = " ".repeat(*indent);
      let whitespace_more: String = " ".repeat(*indent + 2);

      // If the current list item's indent is equal to the next list item's indent
      if *indent == prev_indent {
        // Add the current list item to the list
        result.push_str(&format!("{whitespace_more}{list_item}\n"));
      }
      // If the current list item's indent is greater than the next list item's indent
      else if *indent > prev_indent {
        // Start a new child list and add the current list item to it
        result.push_str(&format!("{whitespace}<{format}>\n{whitespace_more}{list_item}\n"));
        // Update the open lists vector
        open_lists.push((whitespace, format));
      }
      // If the current list item's indent is less than the next list item's indent
      else if *indent < prev_indent {
        // Close the previous list
        let (_, prev_indent, prev_format, _): ListItem = list[index - 1];
        result.push_str(&format!("{}</{}>\n", " ".repeat(prev_indent), prev_format));
        open_lists.pop();
        // Continue with the previous list's parent list
        result.push_str(&format!("{whitespace_more}{list_item}\n"));
      }

      // Update the previous indent
      prev_indent = *indent;
    }

    // Close all unclosed open list using whitespace and format indicators from the `open_lists` vector
    while !open_lists.is_empty() {
      let (whitespace, format): (String, &str) = open_lists.pop().unwrap();
      result.push_str(&format!("{whitespace}</{format}>\n"));
    }

    // Close the parent list
    result.push_str(&format!("</{}>\n", list[0].2));

    // Return the result
    result
  });
}
